## 事件处理程序
### HTML事件处理程序
```javascript
function showMessage(){
    alert("Hello World!");
}
<input type="button" value="Click me" onclick="showMessage()" />
//事件处理程序有两个缺点：1.存在时差问题2.扩展事件处理程序的作用域在不同的浏览器中会导致不同结果
```
### DOM0级事件处理程序
每个元素都有自己的事件处理程序属性，这些属性通常全部小写，例如onclick。将这种属性的值设置为一个函数，就可以指定事件处理程序
```javascript
var btn = document.getElementById("mybtn");
btn.onclick = function(){//以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理
	alert(this.id);
}
```
### DOM2级事件处理程序
```javascript
var btn = document.getElementById("mybtn");
var handle = function(){
	alert(this.id);
}
btn.addEventListener("click",handle,false);//大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容各种浏览器
//这里省略了其他代码
btn.removeEventListener("click",handle,false);
```
###  IE事件处理程序
在IE中使用attachEvent与DOM0级方法的主要区别在于事件处理程序的作用域。在使用DOM0级方法的情况下，事件处理程序会在其所属元素的作用域内运行；在使用attachEvent方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window
```javascript
var btn = document.getElementById("mybtn");
btn.attachEvent("onclick",function(){
	alert(this == window);//true
})
```
###  跨浏览器的事件处理程序
```javascript
var EventUtil = {
	addHandler : function(element,type,handler){
		if(element.addEventListener){
			element.addEventListener(type,handler,false);
		}else if(element.attachEvent){
			element.attachEvent("on" + type,handler);
		}else{
			element["on" + type] = handler;
		}
	},
	removeHandler : function(element,type,handler){
		if(element.removeEventListener){
			element.removeEventListener(type,handler,false);
		}else if(element.detachEvent){
			element.detachEvent("on" + type,handler);
		}else{
			element["on" + type] = null;
		}
	}
}
```
## 事件对象
### DOM中的事件对象
无论指定事件处理程序时使用什么方法，都会传入event对象
```javascript
    var btn = document.getElementById('myBtn');
    btn.onclick = function(event){
        alert(event.type);//"click"
    }
    btn.addEventListener("click",function(event){
        alert(event.type);//"click"
    },false)
```
在事件处理程序内部，对象this始终等于currentTarget的值，而target则只包含事件的实际目标.如果直接将事件处理程序指定给了目标元素，则this、currentTarget、和target包含相同的值
```javascript
    var btn = document.getElementById('myBtn');
    btn.onclick = function(event){
        alert(event.currentTarget == this);//true
        alert(event.target == this);//true
    }
```
如果事件处理程序存在按钮的父节点中，那么这些值是不相同的
```javascript
    document.body.onclick = function(event){
        alert(event.currentTarget == document.body);//true
        alert(this == document.body);//true
        alert(event.target == document.getElementById("myBtn"));//true
    }
```
在需要通过一个函数处理多个事件时，可以使用type属性
```javascript
    var btn = document.getElementById('myBtn');
    var handler = function(event){
        switch(event.type){
            case "click":
                alert("clicked");
                break;
            case "mouseover":
                event.target.style.backgroundColor = "red";
                break;
            case "mouseout":
                event.target.style.backgroundColor = "";
                break;
        }
    };
    btn.onclick = handler;
    btn.onmouseover = handler;
    btn.onmouseout = handler;
    //阻止默认行为
    var link = document.getElementById("myLink");
    link.onclick = function(){
        event.preventDefault()
    }
    //阻止冒泡
    var btn = document.getElementById('myBtn');
    btn.onclick = function(event){
        alert("clicked");
        event.stopPropagation();
    };
    document.body.onclick = function(){
        alert("Body clicked");//不执行
    }
```
### IE中的事件对象
在使用DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在
```javascript
    var btn = document.getElementById('myBtn');
    btn.onclick = function(){
        var event = window.event;
        alert(event.type);//click
    }
```

如果事件处理处理程序是使用attachEvent()方法添加的，那么就会有一个event对象作为参数被传入事件处理程序函数中
```javascript
    var btn = document.getElementById('myBtn');
    btn.attachEvent("click",function(event){
        alert(event.type);//click
    },false)
```
因为事件处理程序的作用域是根据指定它的方式来确定的，所以不能认为this会始终等于事件目标。最好还是使用event.srcElement比较保险
```javascript
    var btn = document.getElementById('myBtn');
    btn.onclick = function(){
        alert(window.event.srcElement == this);//true
    }
    btn.attachEvent("click",function(event){
        alert(event.srcElement == this);//false
    },false)
    //阻止默认行为
    var link = document.getElementById("myLink");
    link.onclick = function(){
        window.event.returnValue = false;
    }
    //阻止冒泡
    var btn = document.getElementById('myBtn');
    btn.onclick = function(){
        alert("clicked");
        window.event.cancelBubble = true;
    };
    document.body.onclick = function(){
        alert("Body clicked");//不执行
    }
```
### 跨浏览器的事件对象
```javascript
var EventUtil = {
    addHandler : function(element,type,handler){
        if(element.addEventListener){
            element.addEventListener(type,handler,false);
        }else if(element.attachEvent){
            element.attachEvent("on" + type,handler);
        }else{
            element["on" + type] = handler;
        }
    },
    removeHandler : function(element,type,handler){
        if(element.removeEventListener){
            element.removeEventListener(type,handler,false);
        }else if(element.detachEvent){
            element.detachEvent("on" + type,handler);
        }else{
            element["on" + type] = null;
        }
    },
    getEvent : function(event){
        return event ? event : window.event;
    },
    getTarget : function(event){
        return event.target || event.srcElement;
    },
    preventDefault : function(event){
        if(event.preventDefault){
            event.preventDefault();
        }else{
            event.returnValue = false;
        }
    },
    stopPropagation : function(event){
        if(event.stopPropagation){
            event.stopPropagation();
        }else{
            event.cancelBubble = true;
        }
    }
}
```
